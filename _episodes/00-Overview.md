---
title: "Module overview"
teaching: 180
exercises: 0
questions:
- "Why should I care ?"
- "Who is this module for ?"
- "How should I study it ?"
objectives:
- "Motivate to think about reproducibility as an inherent aspect of research activities"
- "Use learned materials as soon as feasible"
keypoints:
- "Efficient practices are the (more) reproducible ones"

---

### Introduction

The term "reproducibility" conjures a mental image of dedicated systems
conducting automated and repeatable computations.  However, **you** can
embrace reproducibility as a principle to apply to your day-to-day
research activities.  Neuroimaging is a heavily data and software driven
field of science.  As a result, by learning more tricks and techniques
of the tools that you already use daily, you will discover ways to
not only improve efficiency but also increase the reproducibility of
your research.

To some degree, reproducibility requires knowledge of **what**,
**when**, and **how** any particular analysis was carried out.
Therefore the lessons in this module will focus on helping to
answer those questions.  Before addressing these specific questions,
referenced external materials (tutorials, lessons, etc) will provide a
more generic and more thorough presentation of the topics.


### Who is this module for?

The module is for any scientist, researcher, or a student who is using
software to analyze data, writing custom code or editing documents.

> ## Prerequisites
>
>
> Depending on your level of competence in any particular topic, you
> might like to go through additional materials which will be
> referenced in each particular lesson.  Even if you feel that you are
> very proficient in all of those topics, we hope you would still
> learn some new "tricks" or would recommend or contribute some new
> materials to the lessons.
{: .prereq}

### How much time this should take me?

That primarily depends on your familiarity and experience with working
in command line/shell, using version control systems, managing
software environments, having experience providing constructive
feedback about defects you found in software you use, etc. All those
topics seem independent but also very much related, so it is likely
that you might have some familiarity with all of them, happen you know
well one of them.  If all those topics not familiar to you at all,
this may take you a long time, for instance 5 to 7 full days. If you
have good familiarity, some of the information will be already
partially known and it may take you a few hours to go in detail
through this material.  In each lesson we provide some estimates for
time it would take to go through the lesson having an assumption that
you have some basic familiarity with the topic.

### How acquired knowledge should get used?

It is important to **apply** the knowledge gained from the lessons to
your day-to-day activities as soon as feasible: Start using shell
and/or do it more efficiently (use shortcuts, start scripting, make
those scripts robust, etc.), use version control systems for anything
you change (code, data, documents) and increase "traceable" collaboration
exchange (even though just between you on computer 1 and you on
computer 2), get curious and check what you are using and start
provisioning your own computation environments, report problems you
run into and do not let them just left unresolved.

One of the efficient learning approaches of the materials could be
first to skim through all the materials, while only catching the key
concepts and start applying them right away. Then, having gained some
experience and having stumbled upon some problems, come back and go
through the relevant topic in greater detail while concentrating on
the aspects relevant to your early encounters.

**The least efficient approaches would be to spend a week "learning
it" only to successfully forget all of it by not using any of the
learned tools or recommended practices.**

### What are the lessons in this module?

This module guides through three somewhat independent topics, which
are in the heart of establishing and efficiently using common generic
resources: command line shell, version control systems (for code and
data), distribution package managers, and few additional aspects such
as bug reporting and licensing.  It is very unlikely that you have
managed to avoid using those tools completely in your prior research activities, but it
is possible that you have under-utilized the power they are providing.
Gaining additional skills in any of those topics could help you to not
only become more efficient in your day-to-day research activities, but
also would lay foundation in establishing habits to make your work
actually more reproducible.  Moreover these topics will be in the
foundation of future modules in the ReproNim curriculum.

